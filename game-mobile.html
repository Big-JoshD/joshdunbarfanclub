<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Bean Run — Mobile</title>
  <style>
    :root { --safe-top: env(safe-area-inset-top); --safe-bottom: env(safe-area-inset-bottom); }
    html, body { margin:0; height:100%; background:#0b1a22; overflow:hidden; }
    #wrap { position:fixed; inset:0; padding-top:var(--safe-top); padding-bottom:var(--safe-bottom); }
    canvas { width:100%; height:100%; display:block; image-rendering:pixelated; }

    .hud { position:fixed; inset:0; pointer-events:none; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#eee; }
    .hud .hi { position:absolute; top:8px; left:12px; opacity:.85; text-shadow:0 1px 0 #0008; }
    .hud .score { position:absolute; top:8px; right:12px; font-weight:700; text-shadow:0 1px 0 #0008; }
    .center { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; }
    .card { pointer-events:auto; background:rgba(0,0,0,.35); backdrop-filter:blur(3px); color:#eee; border:1px solid #ffffff1a; border-radius:12px; padding:16px 20px; text-align:center; box-shadow:0 8px 20px rgba(0,0,0,.5); }
    .blink { animation:blink 1.6s infinite; } @keyframes blink { 0%,100%{opacity:.35} 50%{opacity:1} }

    /* Portrait rotate prompt */
    #rotate { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.85); color:#fff; z-index:9999; text-align:center; padding:24px;
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"; }
    #rotate .box { border:1px solid #ffffff22; border-radius:14px; padding:18px 20px; max-width:560px; background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03)); box-shadow:0 12px 28px rgba(0,0,0,.55); }
    #rotate h2 { margin:0 0 .35rem; font-size:1.25rem } #rotate p { margin:.25rem 0 0; opacity:.9; line-height:1.35 }
    @media (orientation: portrait) { #rotate { display:flex; } }
    @media (orientation: landscape) { #rotate { display:none; } }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="game"></canvas></div>

  <div class="hud">
    <div class="hi" id="hi">HI 00000</div>
    <div class="score" id="score">00000</div>
    <div class="center" id="center">
      <div class="card">
        <h2 style="margin:.25rem 0">Bean Run — Mobile</h2>
        <div>Controls: <strong>Hold LEFT = Duck</strong> • <strong>Tap RIGHT = Jump</strong></div>
        <div style="margin-top:.35rem; opacity:.8">For best experience, rotate your phone to landscape.</div>
        <div class="blink" style="margin-top:.65rem">Tap to Start</div>
      </div>
    </div>
  </div>

  <!-- Rotate overlay -->
  <div id="rotate">
    <div class="box">
      <h2>Turn your phone sideways</h2>
      <p><strong>Landscape</strong> recommended.<br/>Controls: <strong>Hold LEFT = Duck</strong>, <strong>Tap RIGHT = Jump</strong>.</p>
    </div>
  </div>

  <script>
  // ---------- Fixed logical canvas ----------
  const LOGICAL_W = 960, LOGICAL_H = 540;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true });

  function resize(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(LOGICAL_W * dpr);
    canvas.height = Math.floor(LOGICAL_H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    rebuildForest();
  }
  addEventListener('resize', resize);
  addEventListener('orientationchange', () => setTimeout(resize, 250));

  // ---------- World ----------
  const W=LOGICAL_W, H=LOGICAL_H;
  let GROUND_Y = H-56, GROUND_H=22;
  const BEAN_FOOT_SINK = 4, groundTop = h => GROUND_Y - h + BEAN_FOOT_SINK;

  const STATE = { started:false, over:false, last:0, speed:6, gravity:1.05, score:0, hi:Number(sessionStorage.getItem('bean_hi')||0) };
  const scoreEl = document.getElementById('score'), hiEl = document.getElementById('hi'), centerEl = document.getElementById('center');
  const fmt = n => n.toString().padStart(5,'0');

  const PLAYER = { x:Math.floor(W*0.18), y:groundTop(40), w:44, h:40, vy:0, duck:false, onGround:true };

  // Obstacles
  const obstacles = [];
  let spawnMs = 900;

  // ---------- Assets (match desktop) ----------
  const IMG = { beanRun:new Image(), beanDuck:new Image(), squirrel:new Image(), swordSquirrel:new Image() };
  IMG.beanRun.src='img/bean_run.png';
  IMG.beanDuck.src='img/bean_duck.png';
  IMG.squirrel.src='img/squirrel.png';           // flying enemy
  IMG.swordSquirrel.src='img/swordsquirrel.png'; // ground enemy

  // ---------- Background ----------
  let layers = null;
  function rebuildForest(){
    layers = [
      makeLayer({speed:0.26, hue:'#50915a', trunk:'#37623c', scale:0.95, step:26}),
      makeLayer({speed:0.48, hue:'#3e864f', trunk:'#2f613b', scale:1.18, step:24}),
      makeLayer({speed:0.80, hue:'#2f7a45', trunk:'#255d36', scale:1.38, step:22}),
    ];
  }
  function makeLayer(o){
    const c=document.createElement('canvas'), g=c.getContext('2d'); c.width=W; c.height=H;
    const base=GROUND_Y;
    for(let x=-20;x<c.width+40;x+=o.step){
      const s=o.scale*(0.9+Math.random()*0.35);
      drawTree(g,x,base,Math.floor(48*s),o.hue,o.trunk);
    }
    return {c,offset:0,speed:o.speed};
  }
  function drawTree(g,x,base,h,leaf,trunk){
    const w=Math.max(12,Math.floor(h*0.42));
    g.fillStyle=leaf; g.beginPath(); g.moveTo(x,base-h); g.lineTo(x-w/2,base); g.lineTo(x+w/2,base); g.closePath(); g.fill();
    g.fillStyle=trunk; g.fillRect(x-2,base,4,Math.max(6,Math.floor(h*0.18)));
  }
  function drawForest(dts, speed){
    const sky = ctx.createLinearGradient(0,0,0,H);
    sky.addColorStop(0,'#cfe8ff'); sky.addColorStop(1,'#a2d0ff');
    ctx.fillStyle=sky; ctx.fillRect(0,0,W,H);
    for(const L of layers){
      L.offset -= speed * L.speed * dts;
      if (L.offset <= -W) L.offset += W;
      ctx.drawImage(L.c, Math.floor(L.offset), 0);
      ctx.drawImage(L.c, Math.floor(L.offset+W), 0);
    }
    ctx.fillStyle='#20331f'; ctx.fillRect(0,GROUND_Y,W,H-GROUND_Y);
  }

  // ---------- Controls: LEFT hold = duck, RIGHT tap = jump ----------
  const leftTouchIds = new Set();
  function startGame(){
    STATE.started=true; STATE.over=false; STATE.score=0;
    STATE.speed=6; obstacles.length=0; spawnMs=900;
    Object.assign(PLAYER,{vy:0,onGround:true,duck:false,w:44,h:40});
    PLAYER.y = groundTop(PLAYER.h);
    centerEl.style.display='none';
  }
  function gameOver(){
    STATE.over=true;
    const s=Math.floor(STATE.score);
    if(s>STATE.hi){ STATE.hi=s; sessionStorage.setItem('bean_hi', String(s)); }
    scoreEl.textContent=fmt(s); hiEl.textContent='HI '+fmt(STATE.hi);
    centerEl.style.display='flex';
    centerEl.querySelector('.card').innerHTML =
      `<h2 style="margin:.25rem 0">Game Over</h2>
       <div>Score: ${fmt(s)}</div>
       <div class="blink" style="margin-top:.5rem">Tap to Retry</div>`;
  }
  function jump(){ if(PLAYER.onGround && STATE.started && !STATE.over){ PLAYER.vy=-10.2; PLAYER.onGround=false; PLAYER.duck=false; } }
  function setDuck(d){ if(STATE.started && !STATE.over) PLAYER.duck = !!d; }

  function isLeft(x){ return x < window.innerWidth * 0.5; }

  // Touch
  canvas.addEventListener('touchstart', (e)=>{
    e.preventDefault();
    if(!STATE.started || STATE.over){ startGame(); }
    for(const t of Array.from(e.changedTouches)){
      if(isLeft(t.clientX)){
        leftTouchIds.add(t.identifier);
        setDuck(true);
      }else{
        jump();
      }
    }
  }, {passive:false});

  canvas.addEventListener('touchend', (e)=>{
    for(const t of Array.from(e.changedTouches)){
      leftTouchIds.delete(t.identifier);
    }
    if(leftTouchIds.size===0) setDuck(false);
  }, {passive:true});

  canvas.addEventListener('touchcancel', (e)=>{
    for(const t of Array.from(e.changedTouches)){
      leftTouchIds.delete(t.identifier);
    }
    if(leftTouchIds.size===0) setDuck(false);
  }, {passive:true});

  // (Optional) Mouse fallback for desktop testing
  let mouseDuck=false;
  canvas.addEventListener('mousedown', (e)=>{
    if(!STATE.started || STATE.over){ startGame(); }
    const x = e.clientX;
    if(isLeft(x)){ mouseDuck=true; setDuck(true); } else { jump(); }
  });
  addEventListener('mouseup', ()=>{ if(mouseDuck){ mouseDuck=false; setDuck(false); } });

  // ---------- Loop ----------
  requestAnimationFrame(loop);
  function loop(now){
    const dt=Math.min(32, now-(STATE.last||now)); STATE.last=now;
    const dts = dt/(1000/60);
    update(dts, dt);
    render(dts);
    requestAnimationFrame(loop);
  }

  function update(dts, dt){
    if(STATE.started && !STATE.over){
      // modest speed ramp + score
      if (STATE.score < 300) STATE.speed += 0.0005 * dts;
      else if (STATE.score < 800) STATE.speed += 0.0008 * dts;
      else STATE.speed += 0.0011 * dts;

      STATE.score += 0.35 * dts;
    }

    // physics
    if(!PLAYER.onGround){
      PLAYER.vy += STATE.gravity * dts * 0.5;
      PLAYER.y  += PLAYER.vy * dts;
      if(PLAYER.y >= groundTop(PLAYER.h)){ PLAYER.y=groundTop(PLAYER.h); PLAYER.vy=0; PLAYER.onGround=true; }
    } else if(PLAYER.duck){ PLAYER.h=32; PLAYER.y=groundTop(PLAYER.h); }
    else { PLAYER.h=40; PLAYER.y=groundTop(PLAYER.h); }

    // parallax
    drawForest(0,0); // (no-op update here—draw handles movement)
    // spawn
    if(STATE.started && !STATE.over){
      spawnMs -= dt;
      if(spawnMs<=0){ spawnObstacle(); spawnMs = rand(currentGapMin(), currentGapMax()); }
    }
    // move + collide
    for(let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i];
      o.x -= STATE.speed * dts;
      if (o.update) o.update(dts, dt);
      if(o.x + o.w < -10){ obstacles.splice(i,1); continue; }
      if (hit(playerBox(), o.box())) { gameOver(); break; }
    }

    // HUD
    scoreEl.textContent = fmt(Math.floor(STATE.score));
    hiEl.textContent    = 'HI ' + fmt(STATE.hi);
  }

  // ---------- Obstacles (desktop-style) ----------
  function spawnObstacle(){
    let type = 0; // ground sword-squirrel default
    if (STATE.score > 180){
      const flyerChance = STATE.score > 500 ? 0.45 : 0.25;
      type = Math.random() < flyerChance ? 1 : 0;
    }
    obstacles.push(type === 0 ? SwordSquirrel() : Squirrel());
  }

  function currentGapMin(){ return STATE.score < 150 ? 900 : STATE.score < 350 ? 750 : STATE.score < 700 ? 600 : 480; }
  function currentGapMax(){ return STATE.score < 150 ?1500 : STATE.score < 350 ?1300 : STATE.score < 700 ?1100 : 950; }

  function SwordSquirrel(){
    const SPRITE_W=64, SPRITE_H=64, SCALE=0.70;
    const w=Math.round(SPRITE_W*SCALE), h=Math.round(SPRITE_H*SCALE);
    const y = GROUND_Y - h + 6;
    const inset = { left:Math.round(w*0.12), right:Math.round(w*0.10), top:Math.round(h*0.14), bot:Math.round(h*0.08) };
    return {
      type:'sword_squirrel', x:W+10, y, w, h, _inset:inset,
      box(){ return { x:this.x+inset.left, y:this.y+inset.top, w:this.w-inset.left-inset.right, h:this.h-inset.top-inset.bot }; },
      draw(){ drawImage(IMG.swordSquirrel, this.x, this.y, this.w, this.h, 0); }
    };
  }

  function Squirrel(){
    const lanes=[GROUND_Y-80, GROUND_Y-120];
    const baseY=lanes[Math.floor(Math.random()*lanes.length)];
    const amp=8+Math.random()*8, period=1000+Math.random()*500, born=performance.now();
    const w=52, h=40;
    return {
      type:'squirrel', x:W+10, y:baseY, w, h, baseY, amp, period, born,
      box(){ const p=2; return {x:this.x+p,y:this.y+p,w:this.w-2*p,h:this.h-2*p}; },
      update(){ const t=(performance.now()-born)/period; this.y = baseY + Math.sin(t*Math.PI*2)*amp; this._tilt = Math.sin(t*Math.PI*2)*0.12; },
      draw(){ drawImage(IMG.squirrel, this.x, this.y, this.w, this.h, this._tilt||0); }
    };
  }

  // ---------- Collision / Render ----------
  const playerBox = ()=>{ const p=6; return {x:PLAYER.x+p, y:PLAYER.y+p, w:PLAYER.w-2*p, h:PLAYER.h-2*p}; };
  const hit = (a,b)=> a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y;

  function render(dts){
    ctx.clearRect(0,0,W,H);
    // background parallax draw + move
    const sky = ctx.createLinearGradient(0,0,0,H);
    sky.addColorStop(0,'#cfe8ff'); sky.addColorStop(1,'#a2d0ff');
    ctx.fillStyle=sky; ctx.fillRect(0,0,W,H);
    for(const L of layers){
      L.offset -= STATE.speed * L.speed * dts;
      if (L.offset <= -W) L.offset += W;
      ctx.drawImage(L.c, Math.floor(L.offset), 0);
      ctx.drawImage(L.c, Math.floor(L.offset+W), 0);
    }
    ctx.fillStyle='#20331f'; ctx.fillRect(0,GROUND_Y,W,H-GROUND_Y);

    // ground strip
    ctx.fillStyle='#3a3328'; ctx.fillRect(0,GROUND_Y,W,GROU ND_H);
    ctx.fillStyle='#4a4238'; const seg=24, off=Math.floor((performance.now()/30)%seg);
    for(let x=-off;x<W;x+=seg){ ctx.fillRect(x,GROUND_Y+GROU ND_H-6,12,3); }

    // player
    const img = (PLAYER.duck && PLAYER.onGround) ? IMG.beanDuck : IMG.beanRun;
    drawImage(img, PLAYER.x, PLAYER.y, PLAYER.w, PLAYER.h, 0);

    // enemies
    for(const o of obstacles) o.draw();
  }

  function drawImage(img,x,y,w,h,rot){
    ctx.save(); ctx.imageSmoothingEnabled=false; ctx.translate(x+w/2,y+h/2); if(rot) ctx.rotate(rot);
    ctx.drawImage(img, 0,0,img.width,img.height, -w/2,-h/2, w,h); ctx.restore();
  }
  const rand=(min,max)=> Math.random()*(max-min)+min;

  // boot
  resize();
  </script>
</body>
</html>
