<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bean Run</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    /* Page‑scoped styles only */
    body.game-page { overflow: hidden; }
    .game-section { max-width: 980px; margin: 2rem auto 3rem; padding: 0 1rem; }
    .game-wrap { position: relative; width: 100%; max-width: 960px; aspect-ratio: 3 / 1; margin: 1rem auto; border-radius: 10px; overflow: hidden; box-shadow: 0 12px 28px rgba(0,0,0,.35); background:#111; }
    canvas { width: 100%; height: 100%; display: block; image-rendering: pixelated; image-rendering: crisp-edges; }
    .hud { position:absolute; inset:0; pointer-events:none; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#eee; }
    .hud .hi { position:absolute; top:8px; left:12px; opacity:.85; text-shadow:0 1px 0 #0008; }
    .hud .score { position:absolute; top:8px; right:12px; font-weight:700; text-shadow:0 1px 0 #0008; }
    .center { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; }
    .card { background:rgba(0,0,0,.6); color:#eee; border:1px solid #ffffff1a; border-radius:10px; padding:14px 18px; text-align:center; }
    .sub { font-size:.92rem; opacity:.9; }
  </style>
</head>
<body class="game-page">

  <main class="game-section content-box">
    <h1 class="section-title">BEAN RUN</h1>
    <p class="reverent-text">Help Bean run home to Josh!</p>

    <div class="game-wrap">
      <canvas id="game" width="960" height="320" tabindex="0" aria-label="Bean Run"></canvas>
      <div class="hud">
        <div class="hi" id="hi">HI 00000</div>
        <div class="score" id="score">00000</div>
        <div class="center" id="center">
          <div class="card">
            <div style="font-weight:700">Press Space / Tap to begin</div>
            <div class="sub">Jump: Space / ▲ &nbsp;•&nbsp; Duck: ▼ &nbsp;•&nbsp; Pause: P</div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
  // ===== Bean Run — minimal, stable build =====
  // Theme: outdoor gym (mountains bg + power racks fg); obstacles: 45lb plate (ground) + triceps rope (air)
  // No power-ups/SFX. Score + session high score only.

  // Canvas
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // HUD
  const scoreEl = document.getElementById('score');
  const hiEl = document.getElementById('hi');
  const centerEl = document.getElementById('center');
  const fmt = n => n.toString().padStart(5,'0');

  // State
  const STATE = {
    started:false, running:false, paused:false, over:false,
    last:0, speed:6,
    score:0, hi: Number(sessionStorage.getItem('bean_hi') || 0),
    gravity: 1.05
  };

  // World
  const GROUND_Y = H - 48, GROUND_H = 20;
  const PLAYER = { x:80, y:GROUND_Y-40, w:44, h:40, vy:0, duck:false, onGround:true };
  const obstacles = [];
  let spawnCooldown = 900; // ms until next obstacle

  // ---------- Input (simple & reliable) ----------
  function startGame(){
    STATE.started = true; STATE.running = true; STATE.over = false; STATE.paused = false;
    STATE.score = 0; STATE.speed = 6; obstacles.length = 0; spawnCooldown = 900;
    PLAYER.y = GROUND_Y - PLAYER.h; PLAYER.vy = 0; PLAYER.onGround = true; PLAYER.duck = false;
    centerEl.style.display = 'none';
    STATE.last = performance.now();
    requestAnimationFrame(loop);
  }

  function startIfReady(){ if (!STATE.started || STATE.over) startGame(); }

  function jump(){
    if (!STATE.running || STATE.paused || STATE.over) return;
    if (PLAYER.onGround){ PLAYER.vy = -10.2; PLAYER.onGround = false; PLAYER.duck = false; }
  }
  function setDuck(d){ if (!STATE.running || STATE.paused || STATE.over) return; PLAYER.duck = !!d; }
  function togglePause(){ if (!STATE.started || STATE.over) return; STATE.paused = !STATE.paused; centerEl.style.display = STATE.paused ? 'flex' : 'none'; }

  window.addEventListener('keydown', (e)=>{
    if (e.code==='Space' || e.code==='ArrowUp') { e.preventDefault(); if (!STATE.started || STATE.over) startGame(); else jump(); }
    if (e.code==='ArrowDown') setDuck(true);
    if (e.code==='KeyP' || e.code==='Escape') togglePause();
  });
  window.addEventListener('keyup', (e)=>{ if (e.code==='ArrowDown') setDuck(false); });

  canvas.addEventListener('click', (e)=>{ e.preventDefault(); startIfReady(); });
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); startIfReady(); }, {passive:false});

  document.addEventListener('DOMContentLoaded', ()=>{ try{ canvas.focus(); }catch{} });

  // ---------- Loop ----------
  function loop(now){
    if (!STATE.running) return;
    const dt = Math.min(32, now - STATE.last); // ms
    const dts = dt / (1000/60);
    STATE.last = now;

    if (!STATE.paused){
      update(dts, dt);
      draw();
    }
    requestAnimationFrame(loop);
  }

  function update(dts, dt){
    // Speed ramp (gentle → stronger as score rises)
    if (STATE.score < 300) STATE.speed += 0.0005 * dts;
    else if (STATE.score < 800) STATE.speed += 0.0008 * dts;
    else STATE.speed += 0.0011 * dts;

    // Spawn difficulty like Chrome dino
    spawnCooldown -= dt;
    if (spawnCooldown <= 0){
      spawnObstacle();
      spawnCooldown = rand(currentGapMin(), currentGapMax());
    }

    // Player physics
    if (!PLAYER.onGround){
      PLAYER.vy += STATE.gravity * dts * 0.5;
      PLAYER.y += PLAYER.vy * dts;
      if (PLAYER.y >= GROUND_Y - PLAYER.h){ PLAYER.y = GROUND_Y - PLAYER.h; PLAYER.vy = 0; PLAYER.onGround = true; }
    } else if (PLAYER.duck){
      PLAYER.h = 32; PLAYER.y = GROUND_Y - PLAYER.h;
    } else { PLAYER.h = 40; PLAYER.y = GROUND_Y - PLAYER.h; }

    // Obstacles
    for (let i = obstacles.length - 1; i >= 0; i--){
      const o = obstacles[i];
      o.x -= STATE.speed * dts;
      if (o.x + o.w < -10) { obstacles.splice(i,1); continue; }
      if (hit(playerBox(), o.box())) { return gameOver(); }
    }

    STATE.score += 0.35 * dts;
    scoreEl.textContent = fmt(Math.floor(STATE.score));
    hiEl.textContent = 'HI ' + fmt(STATE.hi);
  }

  function gameOver(){
    STATE.running = false; STATE.over = true;
    const s = Math.floor(STATE.score);
    if (s > STATE.hi){ STATE.hi = s; sessionStorage.setItem('bean_hi', String(s)); }
    scoreEl.textContent = fmt(s); hiEl.textContent = 'HI ' + fmt(STATE.hi);
    centerEl.style.display = 'flex';
    centerEl.querySelector('.card').innerHTML = `<div style="font-weight:700">Game Over</div><div>Score: ${fmt(s)}</div><div class="sub" style="margin-top:.25rem">Press Space / Tap to retry</div>`;
  }

  // ---------- Obstacles ----------
  function spawnObstacle(){
    let type = 0; // plate by default early
    if (STATE.score > 180){ // ropes later like dino birds
      const ropeChance = STATE.score > 500 ? 0.45 : 0.25;
      type = Math.random() < ropeChance ? 1 : 0;
    }
    obstacles.push(type === 0 ? Plate() : Rope());
  }
  function currentGapMin(){ return STATE.score < 150 ? 900 : STATE.score < 350 ? 750 : STATE.score < 700 ? 600 : 480; }
  function currentGapMax(){ return STATE.score < 150 ? 1500 : STATE.score < 350 ? 1300 : STATE.score < 700 ? 1100 : 950; }

  function Plate(){
    const size = 34, y = GROUND_Y - size + 6; let spin = Math.random()*Math.PI;
    return {
      type:'plate', x: W+10, y, w:size, h:size,
      box(){ const p=6; return {x:this.x+p,y:this.y+p,w:this.w-2*p,h:this.h-2*p}; },
      draw(){
        const cx = this.x + this.w/2, cy = this.y + this.h/2;
        ctx.save(); ctx.translate(cx,cy); spin += 0.18; ctx.rotate(spin);
        ctx.fillStyle = '#2a2a2a'; ctx.beginPath(); ctx.arc(0,0,this.w*0.5,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#3d3d3d'; ctx.beginPath(); ctx.arc(0,0,this.w*0.33,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(0,0,this.w*0.09,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
    };
  }

  function Rope(){
    const lanes = [GROUND_Y - 90, GROUND_Y - 130];
    const baseY = lanes[Math.floor(Math.random()*lanes.length)];
    const amp = 16 + Math.random()*10; const period = 1300 + Math.random()*600; const born = performance.now();
    const w = 18, h = 60;
    return {
      type:'rope', x: W+10, y: baseY, w, h,
      box(){ const t=(performance.now()-born)/period; const sway = Math.sin(t*Math.PI*2)*amp; const x = this.x + sway; return {x:x+4,y:this.y+4,w:this.w-8,h:this.h-8}; },
      draw(){
        const t=(performance.now()-born)/period; const sway = Math.sin(t*Math.PI*2)*amp; const x = this.x + sway;
        ctx.fillStyle = '#222'; ctx.fillRect(x + w*0.45, this.y-20, 2, 20);
        for (let i=0;i<this.h;i+=6){ ctx.fillStyle = i%12===0?'#5a5a5a':'#6b6b6b'; ctx.fillRect(x, this.y+i, this.w, 4); }
        ctx.fillStyle = '#2b2b2b'; ctx.fillRect(x-2, this.y+this.h, this.w+4, 10);
      }
    };
  }

  // ---------- Collision ----------
  const playerBox = () => { const p=6; return {x:PLAYER.x+p, y:PLAYER.y+p, w:PLAYER.w-2*p, h:PLAYER.h-2*p}; };
  const hit = (a,b) => a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;

  // ---------- Render ----------
  function draw(){
    ctx.clearRect(0,0,W,H);
    drawBackground();
    drawGround();
    drawPlayer();
    for (const o of obstacles){ o.draw(); }
  }

  function drawBackground(){
    // sky
    const sky = ctx.createLinearGradient(0,0,0,H); sky.addColorStop(0,'#8fb8ff'); sky.addColorStop(1,'#d7ecff'); ctx.fillStyle = sky; ctx.fillRect(0,0,W,H);
    // mountains parallax
    const speed = STATE.speed*0.2, now = performance.now(); const s1 = (now/24*speed)%W; const s2 = (now/18*(STATE.speed*0.3))%W;
    ctx.fillStyle = '#6d7faa';
    for(let i=-1;i<3;i++){ const b=i*W-s1; mountain(b+0,H-120,b+160,H-220,b+320); mountain(b+240,H-110,b+380,H-190,b+520); mountain(b+500,H-130,b+660,H-230,b+820); }
    ctx.fillStyle = '#556791';
    for(let i=-1;i<3;i++){ const b=i*W-s2; mountain(b+80,H-90,b+210,H-170,b+340); mountain(b+360,H-100,b+490,H-180,b+620); mountain(b+620,H-95,b+750,H-165,b+880); }
  }
  function mountain(x0,by,px,py,x1){ ctx.beginPath(); ctx.moveTo(x0,by); ctx.lineTo(px,py); ctx.lineTo(x1,by); ctx.closePath(); ctx.fill(); }

  function drawGround(){
    ctx.fillStyle = '#2b2b2b'; ctx.fillRect(0,GROUND_Y,W,GROUND_H);
    ctx.fillStyle = '#1f1f1f'; const seg=24, off=Math.floor((performance.now()/30)%seg); for(let x=-off;x<W;x+=seg){ ctx.fillRect(x,GROUND_Y+GROUND_H-6,12,3); }
  }

  function drawPlayer(){
    // placeholder pixel Bean (body/head/ears/collar)
    ctx.fillStyle = '#1b1b1b'; ctx.fillRect(PLAYER.x, PLAYER.y+PLAYER.h-6, PLAYER.w, 6); // shadow
    ctx.fillStyle = '#5a3d2e'; ctx.fillRect(PLAYER.x+6, PLAYER.y+8, PLAYER.w-12, PLAYER.h-12); // body
    ctx.fillRect(PLAYER.x+PLAYER.w-24, PLAYER.y, 20, 16); // head
    ctx.fillStyle = '#3d281f'; ctx.fillRect(PLAYER.x+PLAYER.w-12, PLAYER.y-4, 4, 6); ctx.fillRect(PLAYER.x+PLAYER.w-18, PLAYER.y-4, 4, 6); // ears
    ctx.fillStyle = '#2a58b0'; ctx.fillRect(PLAYER.x+8, PLAYER.y+14, PLAYER.w-26, 3); // collar
    ctx.fillStyle = '#5a3d2e'; ctx.fillRect(PLAYER.x+2, PLAYER.y+16, 6, 4); // tail
  }

  // Utilities
  const rand = (min,max)=> Math.random()*(max-min)+min;

  // Navbar inject (simple)
  fetch('navbar.html').then(r=>r.text()).then(html=>{ const nav=document.createElement('div'); nav.innerHTML=html; document.body.insertBefore(nav, document.body.firstChild); });
  </script>
</body>
</html>
