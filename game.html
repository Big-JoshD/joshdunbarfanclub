<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bean Run — Lightning (Blue, High-Contrast)</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    /* Page-scoped styles only */
    body.game-page { overflow-x: hidden; }
    .game-section { max-width: 980px; margin: 2rem auto 1rem; padding: 0 1rem; }
    .game-wrap { position: relative; width: 100%; max-width: 960px; aspect-ratio: 3 / 1; margin: 1rem auto; border-radius: 10px; overflow: hidden; box-shadow: 0 12px 28px rgba(0,0,0,.35); background:#111; }
    canvas { width: 100%; height: 100%; display: block; image-rendering: pixelated; image-rendering: crisp-edges; }
    .hud { position:absolute; inset:0; pointer-events:none; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#eee; }
    .hud .hi { position:absolute; top:8px; left:12px; opacity:.85; text-shadow:0 1px 0 #0008; }
    .hud .score { position:absolute; top:8px; right:12px; font-weight:700; text-shadow:0 1px 0 #0008; padding-right: 26px; }
    /* Lightning availability icon next to score */
    .hud .boltIcon {
      position:absolute; top:8px; right:8px; width:18px; height:18px; pointer-events:none;
      display:none; /* shown when charged */
    }
    .hud .boltIcon svg { width:100%; height:100%; filter: drop-shadow(0 0 2px rgba(143,211,255,0.8)); }
    .center { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; }
    .card { background:rgba(0,0,0,.35); backdrop-filter: blur(2px); color:#eee; border:1px solid #ffffff1a; border-radius:10px; padding:10px 14px; text-align:center; }
    .card h2{ margin:.1rem 0 .1rem; letter-spacing:.02em; font-size:1.1rem; }
    .sub { font-size:.9rem; opacity:.9; }
    .blink { animation: blink 1.6s infinite; }
    @keyframes blink { 0%,100%{opacity:.35} 50%{opacity:.95} }

    /* Floating lightning fire button (mobile only when charged) */
    #lightningBtn{
      position:fixed; right:14px; bottom:14px; width:64px; height:64px; border-radius:12px;
      font-size:28px; z-index:9999; display:none; border:none; cursor:pointer; pointer-events:auto;
      background:linear-gradient(#80d8ff,#40c4ff); color:#00324d;
      box-shadow:0 6px 18px rgba(0,0,0,0.4);
    }

    /* Controls box under game */
    .controls {
      max-width: 960px; margin: 0.5rem auto 2.5rem; padding: 0 1rem;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .controls .box{
      background: #0b1220; color:#dbe7ff; border:1px solid #1c2742; border-radius: 10px;
      padding: 12px 14px; box-shadow: 0 6px 20px rgba(0,0,0,.25);
    }
    .controls h3{ margin:.2rem 0 .6rem; font-size:1rem; letter-spacing:.02em; color:#c8dcff; }
    .controls ul{ margin:0; padding-left: 1.1rem; }
    .controls li{ margin:.2rem 0; }
    code.k { background:#111a2a; border:1px solid #20304d; padding:.05rem .35rem; border-radius:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body class="game-page">

  <main class="game-section content-box">
    <h1 class="section-title">BEAN RUN</h1>
    <p class="reverent-text">Help Bean sprint through the forest — dodge the evil squirrels!</p>

    <div class="game-wrap">
      <canvas id="game" width="960" height="320" tabindex="0" aria-label="Bean Run"></canvas>
      <div class="hud">
        <div class="hi" id="hi">HI 00000</div>
        <div class="score" id="score">00000</div>
        <!-- Lightning availability icon -->
        <div class="boltIcon" id="boltIcon" aria-hidden="true">
          <svg viewBox="0 0 24 24" role="img" aria-label="Lightning ready">
            <path d="M12 2 L6 14 L11 14 L9 22 L18 9 L12 9 Z"
              fill="#a9e2ff" stroke="#000" stroke-width="2" />
          </svg>
        </div>
        <div class="center" id="center">
          <div class="card start">
            <h2>Bean Run</h2>
            <div class="sub blink">Click / Tap / Space to Start</div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Controls under the game -->
  <section class="controls">
    <div class="box">
      <h3>Controls</h3>
      <ul>
        <li><code class="k">Space</code> / tap canvas — Start &amp; Jump</li>
        <li><code class="k">Down Arrow</code> — Duck</li>
        <li><code class="k">Right Arrow</code> — Fire Lightning (when charged)</li>
        <li><code class="k">P</code> or <code class="k">Esc</code> — Pause</li>
      </ul>
    </div>
  </section>

  <!-- Lightning fire button (shows only when you have power) -->
  <button id="lightningBtn" aria-label="Fire Lightning">⚡</button>

  <script>
  // ===== Bean Run — Forest Parallax + BLUE Lightning =====

  // Canvas
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const FRAME_MS = 1000/60;

  // HUD
  const scoreEl = document.getElementById('score');
  const hiEl = document.getElementById('hi');
  const centerEl = document.getElementById('center');
  const fireBtn = document.getElementById('lightningBtn');
  const boltIcon = document.getElementById('boltIcon');
  const fmt = n => n.toString().padStart(5,'0');

  // State
  const STATE = {
    started:false, paused:false, over:false,
    last:0, speed:6,
    score:0, hi: Number(sessionStorage.getItem('bean_hi') || 0),
    gravity: 1.05
  };

  // World
  const GROUND_Y = H - 48, GROUND_H = 20;
  const BEAN_FOOT_SINK = 4;
  const groundTop = (h) => GROUND_Y - h + BEAN_FOOT_SINK;

  const PLAYER = { x:80, y:groundTop(40), w:44, h:40, vy:0, duck:false, onGround:true };
  const obstacles = [];
  let spawnCooldown = 900;

  // Demo / attract
  const DEMO = {
    speedTarget: 2.8, maxObstacles: 2, minGapPx: 260,
    spawnMin: 1200, spawnMax: 1700, jumpCooldownMs: 650,
    horizonFrames: 180, jumpVy: -9.6
  };
  let demoCooldown = rand(DEMO.spawnMin, DEMO.spawnMax);
  let lastJumpAt = 0;

  // Power-ups / projectiles / particles
  const powerups = [];
  const projectiles = [];
  const particles = [];

  const POWER = {
    have:false,
    spawnEveryScore: 120,
    lastSpawnScore: -999,
    spawnChance: 0.55,
    scoreBonus: 18
  };

  // Assets
  const IMG = {
    beanRun: new Image(),
    beanDuck: new Image(),
    squirrel: new Image(),
    swordSquirrel: new Image(),
  };
  IMG.beanRun.src = 'img/bean_run.png';
  IMG.beanDuck.src = 'img/bean_duck.png';
  IMG.squirrel.src = 'img/squirrel.png';
  IMG.swordSquirrel.src = 'img/swordsquirrel.png';

  // Background
  const BG = makeForestBackground(W, H, GROUND_Y);

  function makeForestBackground(W, H, groundY){
  // layer configs (you can tweak colors/heights later)
  const cfgs = [
    { speedMul:0.10, hue:'#50915a', trunk:'#37623c', baseH:44, scale:0.95, jitterY:6,  step:26 }, // far
    { speedMul:0.20, hue:'#3e864f', trunk:'#2f613b', baseH:56, scale:1.10, jitterY:8,  step:24 }, // mid
    { speedMul:0.32, hue:'#2f7a45', trunk:'#255d36', baseH:66, scale:1.25, jitterY:10, step:22 }, // near
  ];

  const layers = cfgs.map(c => makeLayer(W, H, groundY, c));
  let skyGrad;

  return {
    update(dts, worldSpeed){
      for (const L of layers){
        // snap offset to integer px to avoid subpixel resampling flicker
        L.offset -= worldSpeed * L.speedMul * dts;
        // wrap and quantize
        if (L.offset <= -L.canvas.width) L.offset += L.canvas.width;
        L.offset = Math.round(L.offset); // <-- pixel snapping
      }
    },
    draw(ctx){
      if (!skyGrad){
        skyGrad = ctx.createLinearGradient(0,0,0,H);
        skyGrad.addColorStop(0.00, '#cfe8ff');
        skyGrad.addColorStop(0.55, '#b8dcff');
        skyGrad.addColorStop(1.00, '#a2d0ff');
      }
      ctx.fillStyle = skyGrad; ctx.fillRect(0,0,W,H);

      // draw each layer twice to cover wrap; image smoothing off for crisp pixels
      ctx.imageSmoothingEnabled = false;
      for (const L of layers){
        const x1 = L.offset|0;
        const x2 = x1 + L.canvas.width;
        ctx.drawImage(L.canvas, x1, 0);
        ctx.drawImage(L.canvas, x2, 0);
      }

      // ground
      ctx.fillStyle = '#20331f';
      ctx.fillRect(0, groundY, W, H - groundY);
    }
  };

  function makeLayer(W, H, groundY, opts){
    const c = document.createElement('canvas');
    const g = c.getContext('2d');
    // oversize so wrapping never shows seams
    c.width  = Math.max(W, 640) + 64;
    c.height = H;
    g.imageSmoothingEnabled = false;

    const base = groundY, step = opts.step || 24;
    for (let x = -20; x < c.width + 40; x += step){
      const s = opts.scale * (0.92 + Math.random()*0.28);
      const y = base + Math.round((Math.random()*opts.jitterY) - opts.jitterY*0.5);
      const cluster = 2 + (Math.random() < 0.6 ? 1 : 0);
      for (let i=0;i<cluster;i++){
        drawPine(
          g,
          Math.round(x + (i-0.5)*10),
          y,
          Math.round((opts.baseH||48)*s*(1 + i*0.05)),
          opts.hue,
          opts.trunk
        );
      }
    }
    return { canvas: c, offset: 0, speedMul: opts.speedMul };
  }

  // Draw a pine with 1px black outlines on leaves and trunk
  function drawPine(g, x, baseY, h, leafColor, trunkColor){
    const w       = Math.max(12, Math.round(h*0.42));
    const trunkW  = Math.max(3,  Math.round(w*0.18));
    const trunkH  = Math.max(5,  Math.round(h*0.22));
    const topY    = baseY - h;
    const tiers   = 3;

    // leaf tiers (filled + 1px black stroke)
    for (let t=0; t<tiers; t++){
      const ty = Math.round(topY + (t/tiers)*h*0.78);
      const tw = Math.round(w - t*(w*0.22));
      const th = Math.round(h*0.34);

      g.beginPath();
      g.moveTo(x|0, ty|0);
      g.lineTo((x - (tw>>1))|0, (ty + th)|0);
      g.lineTo((x + (tw>>1))|0, (ty + th)|0);
      g.closePath();

      // fill first
      g.fillStyle = leafColor;
      g.fill();

      // crisp 1px outline (no dashes)
      g.lineJoin = 'miter';
      g.lineCap  = 'butt';
      g.strokeStyle = '#000';
      g.lineWidth   = 1;
      g.stroke();
    }

    // trunk (fill + 1px stroke)
    const tx = Math.round(x - trunkW/2);
    const ty = Math.round(baseY - trunkH);
    g.fillStyle = trunkColor;
    g.fillRect(tx, ty, trunkW, trunkH);

    // use strokeRect with integer coords for crisp 1px
    g.strokeStyle = '#000';
    g.lineWidth = 1;
    g.strokeRect(tx + 0.5, ty + 0.5, trunkW - 1, trunkH - 1);
  }
}
    function makeLayer(W, H, groundY, opts){
      const c = document.createElement('canvas');
      const g = c.getContext('2d');
      c.width = Math.max(W, 640); c.height = H;
      const base = groundY, step = opts.step || 24;
      for (let x = -20; x < c.width + 40; x += step){
        const s = opts.scale * (0.9 + Math.random()*0.35);
        const y = base + Math.floor((Math.random()*opts.jitterY) - opts.jitterY*0.5);
        const cluster = 2 + (Math.random() < 0.6 ? 1 : 0);
        for (let i=0;i<cluster;i++){
          drawPine(g, Math.floor(x + (i-0.5)*10), y, Math.floor((opts.baseH||48)*s*(1 + i*0.05)), opts.hue, opts.trunk);
        }
      }
      return {canvas:c, offset:0, speedMul:opts.speedMul};
    }
    function drawPine(g, x, baseY, h, leafColor, trunkColor){
      const w = Math.max(12, Math.floor(h*0.42));
      const trunkW = Math.max(3, Math.floor(w*0.18));
      const trunkH = Math.max(5, Math.floor(h*0.22));
      const topY = baseY - h;
      g.fillStyle = leafColor;
      const tiers = 3;
      for (let t=0; t<tiers; t++){
        const ty = Math.floor(topY + (t/tiers)*h*0.78);
        const tw = Math.floor(w - t*(w*0.22));
        drawIsoTri(g, x, ty, tw, Math.floor(h*0.34));
      }
      g.fillStyle = trunkColor;
      g.fillRect(Math.floor(x - trunkW/2), Math.floor(baseY - trunkH), trunkW, trunkH);
    }
    function drawIsoTri(g, cx, topY, baseW, h){
      const half = Math.floor(baseW/2);
      g.beginPath();
      g.moveTo(Math.floor(cx), Math.floor(topY));
      g.lineTo(Math.floor(cx - half), Math.floor(topY + h));
      g.lineTo(Math.floor(cx + half), Math.floor(topY + h));
      g.closePath(); g.fill();
    }
  }

  // Input
  function startGame(){
    STATE.started = true; STATE.over = false; STATE.paused = false;
    STATE.score = 0; STATE.speed = 6; obstacles.length = 0; spawnCooldown = 900; lastJumpAt = 0;
    powerups.length = 0; projectiles.length = 0; particles.length = 0; POWER.have = false; boltIcon.style.display='none'; fireBtn.style.display = 'none';
    Object.assign(PLAYER, { y: groundTop(40), w:44, h:40, vy:0, duck:false, onGround:true });
    centerEl.style.display = 'none';
  }
  const startIfReady = ()=>{ if (!STATE.started || STATE.over) startGame(); };
  function jump(){ if (!STATE.started || STATE.paused || STATE.over) return; if (PLAYER.onGround){ PLAYER.vy = -10.2; PLAYER.onGround = false; PLAYER.duck = false; } }
  function setDuck(d){ if (!STATE.started || STATE.paused || STATE.over) return; PLAYER.duck = !!d; }
  function togglePause(){
  if (!STATE.started || STATE.over) return;
  STATE.paused = !STATE.paused;

  if (STATE.paused) {
    // show pause overlay
    centerEl.style.display = 'flex';
    centerEl.querySelector('.card').innerHTML = `
      <h2>Paused</h2>
      <div class="sub" style="margin-top:.25rem">Press <code>P</code> or <code>Esc</code> to resume</div>
    `;
  } else {
    // hide overlay and resume
    centerEl.style.display = 'none';
  }
}

  window.addEventListener('keydown', (e)=>{
    if (e.code==='Space' || e.code==='ArrowUp'){ e.preventDefault(); if (!STATE.started || STATE.over) startGame(); else jump(); }
    if (e.code==='ArrowDown') setDuck(true);
    if (e.code==='ArrowRight') fireLightning(); // RIGHT ARROW to fire
    if (e.code==='KeyP' || e.code==='Escape') togglePause();
  });
  window.addEventListener('keyup', (e)=>{ if (e.code==='ArrowDown') setDuck(false); });
  canvas.addEventListener('click', (e)=>{ e.preventDefault(); startIfReady(); });
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); startIfReady(); }, {passive:false});
  fireBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); fireLightning(); });

  document.addEventListener('DOMContentLoaded', ()=>{ try{ canvas.focus(); }catch{} });

  // Loop
  requestAnimationFrame(loop);
  function loop(now){
    const dt = Math.min(32, now - STATE.last);
    const dts = dt / (1000/60);
    STATE.last = now;

    if (!STATE.paused){
      if (STATE.started) updatePlay(dts, dt, now); else updateAttract(dts, dt, now);
      draw(now);
    }
    requestAnimationFrame(loop);
  }

  // Update: Play
  function updatePlay(dts, dt, now){
    if (STATE.score < 300) STATE.speed += 0.0005 * dts;
    else if (STATE.score < 800) STATE.speed += 0.0008 * dts;
    else STATE.speed += 0.0011 * dts;

    BG.update(dts, STATE.speed * 0.40);

    // Spawn progression
    spawnCooldown -= dt;
    if (spawnCooldown <= 0){
      if (!POWER.have && canSpawnPower() && Math.random() < POWER.spawnChance) {
        spawnPowerup();
      } else {
        spawnObstacle();
      }
      spawnCooldown = rand(currentGapMin(), currentGapMax());
    }

    // Player physics
    if (!PLAYER.onGround){
      PLAYER.vy += STATE.gravity * dts * 0.5;
      PLAYER.y  += PLAYER.vy * dts;
      if (PLAYER.y >= groundTop(PLAYER.h)) { PLAYER.y = groundTop(PLAYER.h); PLAYER.vy = 0; PLAYER.onGround = true; }
    } else if (PLAYER.duck){
      PLAYER.h = 32; PLAYER.y = groundTop(PLAYER.h);
    } else { PLAYER.h = 40; PLAYER.y = groundTop(PLAYER.h); }

    // Move powerups & collect
    for (let i=powerups.length-1;i>=0;i--){
      const p = powerups[i];
      p.x -= STATE.speed * dts;
      if (p.x + p.w < -10) { powerups.splice(i,1); continue; }
      if (hit(playerBox(), p.box())){ powerups.splice(i,1); POWER.have = true; boltIcon.style.display='block'; fireBtn.style.display = 'block'; }
    }

    // Obstacles + collisions
    for (let i = obstacles.length - 1; i >= 0; i--){
      const o = obstacles[i];
      o.x -= STATE.speed * dts;
      if (o.x + o.w < -10) { obstacles.splice(i,1); continue; }
      if (hit(playerBox(), o.box())) { return gameOver(); }
    }

    // Bolt homing
    for (let i=projectiles.length-1;i>=0;i--){
      const b = projectiles[i];
      if (!b.target || !obstacles.includes(b.target)){
        b.target = nearestTargetAhead();
        if (!b.target){ projectiles.splice(i,1); continue; }
      }
      const tc = obstacleCenter(b.target);
      const dx = tc.x - b.x, dy = tc.y - b.y;
      const dist = Math.hypot(dx,dy) || 1;
      const step = Math.min(b.speed * dts, dist);
      b.x += (dx / dist) * step;
      b.y += (dy / dist) * step;
      b.history.push({x:b.x, y:b.y, t:now});
      if (b.history.length > 14) b.history.shift();

      // impact?
      const bb = {x:b.x-3, y:b.y-3, w:6, h:6};
      if (hit(bb, b.target.box())){
        explodeAt(tc.x, tc.y);
        const idx = obstacles.indexOf(b.target);
        if (idx >= 0) obstacles.splice(idx,1);
        STATE.score += POWER.scoreBonus;
        projectiles.splice(i,1);
      }
    }

    // particles
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.vx *= 0.98; p.vy += 0.22;
      p.x += p.vx * dts; p.y += p.vy * dts;
      p.life -= dt;
      if (p.life <= 0) particles.splice(i,1);
    }

    STATE.score += 0.35 * dts;
    scoreEl.textContent = fmt(Math.floor(STATE.score));
    hiEl.textContent = 'HI ' + fmt(STATE.hi);
  }

  // Update: Attract (preview)
  function updateAttract(dts, dt, now){
    STATE.speed += (DEMO.speedTarget - STATE.speed) * 0.08 * dts;
    BG.update(dts, STATE.speed);

    demoCooldown -= dt;
    if (demoCooldown <= 0){
      if (obstacles.length < DEMO.maxObstacles && farEnoughFromLast(DEMO.minGapPx)){
        spawnObstacleDemo();
      }
      demoCooldown = rand(DEMO.spawnMin, DEMO.spawnMax);
    }

    const nowMs = performance.now();
    if (!PLAYER.onGround){
      PLAYER.vy += STATE.gravity * dts * 0.5;
      PLAYER.y  += PLAYER.vy * dts;
      if (PLAYER.y >= groundTop(PLAYER.h)) { PLAYER.y = groundTop(PLAYER.h); PLAYER.vy = 0; PLAYER.onGround = true; }
    } else {
      PLAYER.h = 40; PLAYER.y = groundTop(PLAYER.h);
      const o = nextObstacleAhead();
      if (o){
        const willHitIfNoJump = predictCollisionForObstacle(o, false);
        const willHitIfJump   = predictCollisionForObstacle(o, true);
        if (willHitIfNoJump && !willHitIfJump && (nowMs - lastJumpAt) > DEMO.jumpCooldownMs){
          PLAYER.vy = DEMO.jumpVy; PLAYER.onGround = false; lastJumpAt = nowMs;
        }
      }
    }

    for (let i = obstacles.length - 1; i >= 0; i--){
      const o = obstacles[i];
      o.x -= STATE.speed * dts;
      if (o.x + o.w < -10) { obstacles.splice(i,1); }
    }

    const demoScore = Math.floor((performance.now()/1000) % 9999);
    scoreEl.textContent = fmt(demoScore);
    hiEl.textContent = 'HI ' + fmt(STATE.hi);
  }

  // Predictive helpers
  function predictCollisionForObstacle(o, jumpNow){
    let px = PLAYER.x, pw = PLAYER.w, ph = 40;
    let py = groundTop(ph);
    let vy = jumpNow ? DEMO.jumpVy : 0;
    let onGround = !jumpNow;
    let ox = o.x;
    for (let f = 0; f < DEMO.horizonFrames; f++){
      ox -= STATE.speed;
      if (!onGround){
        vy += STATE.gravity * 0.5;
        py += vy;
        if (py >= groundTop(ph)) { py = groundTop(ph); vy = 0; onGround = true; }
      }
      const pb = { x: px+6, y: py+6, w: pw-12, h: ph-12 };
      const ob = futureObstacleBox(o, ox, f);
      if (hit(pb, ob)) return true;
      if (ox + ob.w < px - 20) return false;
    }
    return false;
  }
  function futureObstacleBox(o, futureX, f){
    if (o.type === 'squirrel'){
      const t = ((performance.now() + f*FRAME_MS) - o.born) / o.period;
      const y = o.baseY + Math.sin(t * Math.PI * 2) * o.amp;
      const p = 2; return { x: futureX+p, y: y+p, w: o.w-2*p, h: o.h-2*p };
    } else {
      const L = o._inset;
      return { x: futureX + L.left, y: o.y + L.top, w: o.w - L.left - L.right, h: o.h - L.top - L.bot };
    }
  }
  function farEnoughFromLast(minGap){
    let rightMost = -Infinity;
    for (const o of obstacles){ rightMost = Math.max(rightMost, o.x + o.w); }
    return (W - rightMost) > minGap;
  }
  function nextObstacleAhead(){
    let best = null, bestDx = Infinity;
    for (const o of obstacles){
      const dx = o.x - (PLAYER.x + PLAYER.w);
      if (dx > 0 && dx < bestDx){ best = o; bestDx = dx; }
    }
    return best;
  }

  // Game over
  function gameOver(){
    STATE.over = true; STATE.started = false;
    const s = Math.floor(STATE.score);
    if (s > STATE.hi){ STATE.hi = s; sessionStorage.setItem('bean_hi', String(s)); }
    scoreEl.textContent = fmt(s); hiEl.textContent = 'HI ' + fmt(STATE.hi);
    centerEl.style.display = 'flex';
    centerEl.querySelector('.card').innerHTML = `<h2>Game Over</h2><div>Score: ${fmt(s)}</div><div class=\"sub\" style=\"margin-top:.25rem\">Click / Tap / Space to retry</div>`;
    obstacles.length = 0; demoCooldown = rand(DEMO.spawnMin, DEMO.spawnMax); STATE.speed = DEMO.speedTarget; lastJumpAt = 0;
    powerups.length = 0; projectiles.length = 0; particles.length = 0; POWER.have = false; boltIcon.style.display='none'; fireBtn.style.display = 'none';
  }

  // Obstacles
  function spawnObstacle(){
    let type = 0;
    if (STATE.score > 180){
      const flyerChance = STATE.score > 500 ? 0.45 : 0.25;
      type = Math.random() < flyerChance ? 1 : 0;
    }
    obstacles.push(type === 0 ? SwordSquirrel() : Squirrel());
  }
  function spawnObstacleDemo(){
    const type = Math.random() < 0.65 ? 0 : 1;
    obstacles.push(type === 0 ? SwordSquirrel() : Squirrel());
  }
  function currentGapMin(){ return STATE.score < 150 ? 900 : STATE.score < 350 ? 750 : STATE.score < 700 ? 600 : 480; }
  function currentGapMax(){ return STATE.score < 150 ? 1500 : STATE.score < 350 ? 1300 : STATE.score < 700 ? 1100 : 950; }

  function SwordSquirrel(){
    const SPRITE_W = 64, SPRITE_H = 64, SCALE = 0.70;
    const w = Math.round(SPRITE_W * SCALE);
    const h = Math.round(SPRITE_H * SCALE);
    const y = GROUND_Y - h + 6;
    const inset = { left:Math.round(w*0.12), right:Math.round(w*0.10), top:Math.round(h*0.14), bot:Math.round(h*0.08) };
    return {
      type: 'sword_squirrel', x: W+10, y, w, h, _inset: inset,
      box(){ return { x:this.x+inset.left, y:this.y+inset.top, w:this.w-inset.left-inset.right, h:this.h-inset.top-inset.bot }; },
      draw(){ ctx.imageSmoothingEnabled = false; drawImage(IMG.swordSquirrel, this.x, this.y, this.w, this.h, 0); }
    };
  }
  function Squirrel(){
    const lanes = [GROUND_Y - 80, GROUND_Y - 120];
    const baseY = lanes[Math.floor(Math.random()*lanes.length)];
    const amp = 8 + Math.random()*8;
    const period = 1000 + Math.random()*500;
    const born = performance.now();
    const w = 52, h = 40;
    return {
      type:'squirrel', x: W+10, y: baseY, w, h, baseY, amp, period, born,
      box(){ const p = 2; return { x:this.x+p, y:this.y+p, w:this.w-2*p, h:this.h-2*p }; },
      draw(){
        const t = (performance.now() - born) / period;
        const bob = Math.sin(t * Math.PI * 2) * amp;
        const tilt = Math.sin(t * Math.PI * 2) * 0.12;
        this.y = baseY + bob;
        if (IMG.squirrel.complete){ drawImage(IMG.squirrel, this.x, this.y, this.w, this.h, tilt); }
        else {
          ctx.fillStyle = '#1b1b1b'; ctx.fillRect(this.x, this.y + this.h - 4, this.w, 4);
          ctx.fillStyle = '#111';     ctx.fillRect(this.x + 6, this.y + 8, this.w - 12, this.h - 12);
          ctx.fillStyle = '#700';     ctx.fillRect(this.x + 2, this.y + 6, 12, 6);
          ctx.fillStyle = '#700';     ctx.fillRect(this.x + this.w - 14, this.y + 6, 12, 6);
          ctx.fillStyle = '#111';     ctx.fillRect(this.x + this.w - 10, this.y + 8, 8, 6);
        }
      }
    };
  }

  // Collision
  const playerBox = () => { const p=6; return {x:PLAYER.x+p, y:PLAYER.y+p, w:PLAYER.w-2*p, h:PLAYER.h-2*p}; };
  const hit = (a,b) => a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;

  // Powerups / projectiles / particles helpers
  function canSpawnPower(){
    const s = Math.floor(STATE.score);
    return (s - POWER.lastSpawnScore) >= POWER.spawnEveryScore;
  }

  // ——— POWER-UP: multi-hue bolt + additive particle aura (no lines) ———
function spawnPowerup(){
  POWER.lastSpawnScore = Math.floor(STATE.score);
  const x = W + 20;
  const lanes = [GROUND_Y - 80, GROUND_Y - 110];
  const y = lanes[Math.floor(Math.random()*lanes.length)];
  powerups.push({
    x, y, w: 28, h: 28,
    aura: [], // particles bound to this pickup
    box(){ return {x:this.x+4, y:this.y+4, w:this.w-8, h:this.h-8}; },
    draw(){
      const t = performance.now();
      const cx = this.x + this.w/2, cy = this.y + this.h/2;
      const rot = ((t/180)%360) * Math.PI/180;
      const pulse = 0.9 + Math.sin(t*0.006)*0.1;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(rot);

      // ---------- main bolt (perfect as-is, no black) ----------
      const bolt = new Path2D();
      bolt.moveTo(-6,-10);
      bolt.lineTo( 1,-2);
      bolt.lineTo(-2, 1);
      bolt.lineTo( 6,12);
      bolt.lineTo( 0, 4);
      bolt.lineTo( 3, 2);
      bolt.closePath();

      // soft purple aura
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.lineJoin = 'round'; ctx.lineCap = 'round';
      ctx.lineWidth = 5.5;
      ctx.strokeStyle = `rgba(150, 70, 255, ${0.45*pulse})`;
      ctx.stroke(bolt);
      ctx.restore();

      // blue edge light
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.lineWidth = 3.0;
      ctx.strokeStyle = `rgba(80, 190, 255, 0.85)`;
      ctx.stroke(bolt);
      ctx.restore();

      // cyan fill + glow
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.shadowColor = 'rgba(120,210,255,0.8)';
      ctx.shadowBlur = 10 * pulse;
      const grad = ctx.createLinearGradient(-6,-10,6,12);
      grad.addColorStop(0.00, '#9fe4ff');  // blue
      grad.addColorStop(0.60, '#e9fbff');  // white
      grad.addColorStop(1.00, '#b3e8ff');  // blue
      ctx.fillStyle = grad;
      ctx.fill(bolt);
      ctx.restore();

      // thin white-hot core + dancing yellow specs
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.lineWidth = 1.2;
      ctx.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx.stroke(bolt);
      ctx.lineWidth = 1.0;
      ctx.setLineDash([3, 10]);
      ctx.lineDashOffset = (t * 0.02) % 13;
      ctx.strokeStyle = 'rgba(255,235,130,0.85)';
      ctx.stroke(bolt);
      ctx.setLineDash([]);
      ctx.restore();

      // ---------- PARTICLE AURA (multi-hue, additive blend) ----------
      const BASE_R = 14;
      const TARGET_COUNT = 26; // feel free to tweak
      // seed more until target count
      while (this.aura.length < TARGET_COUNT){
        this.aura.push({
          seed: Math.random()*9999,
          ang: Math.random()*Math.PI*2,
          angSpeed: (0.6 + Math.random()*0.9) * (Math.random()<0.5 ? 1 : -1), // both directions
          rWobble: 2 + Math.random()*3,
          size: 0.5 + Math.random()*1.6,  // px
          hue: ['blue','white','yellow','purple'][Math.floor(Math.random()*4)],
          ttl: 800 + Math.random()*1200, // ms
          born: t - Math.random()*600,   // stagger births
          drift: 0.3 + Math.random()*0.7 // outward drift on late life
        });
      }

      // update + draw
      for (let i=this.aura.length-1; i>=0; i--){
        const p = this.aura[i];
        const life = (t - p.born);
        const k = Math.min(1, Math.max(0, life / p.ttl)); // 0..1
        // respawn finished particles
        if (life > p.ttl){
          this.aura.splice(i,1);
          continue;
        }

        // orbit + wobble radius + slight outward drift late in life
        p.ang += p.angSpeed * 0.015;
        const wob = Math.sin((t*0.006) + p.seed) * p.rWobble;
        const r   = BASE_R + wob + p.drift * k * 4;
        const x   = Math.cos(p.ang) * r;
        const y   = Math.sin(p.ang) * r;

        // scale + alpha pulse
        const s   = p.size * (0.9 + 0.2*Math.sin((t*0.012)+p.seed)) * (1 - k*0.15);
        const a   = (0.65 + 0.35*Math.sin((t*0.01)+p.seed)) * (1 - k*k*0.6); // fade out near end

        // color layers (no black, additive)
        let c1, c2;
        switch(p.hue){
          case 'white':  c1='rgba(255,255,255,'+(0.55*a)+')'; c2='rgba(240,250,255,'+(0.95*a)+')'; break;
          case 'yellow': c1='rgba(255,235,130,'+(0.45*a)+')'; c2='rgba(255,250,200,'+(0.90*a)+')'; break;
          case 'purple': c1='rgba(150,70,255,'+(0.35*a)+')';  c2='rgba(200,150,255,'+(0.80*a)+')'; break;
          default:       c1='rgba(110,210,255,'+(0.45*a)+')'; c2='rgba(180,235,255,'+(0.95*a)+')';
        }

        // draw as small radial glow dot
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const rg = ctx.createRadialGradient(x, y, 0, x, y, s*2.8);
        rg.addColorStop(0, c2);
        rg.addColorStop(1, c1);
        ctx.fillStyle = rg;
        ctx.beginPath();
        ctx.arc(x, y, s*2.8, 0, Math.PI*2);
        ctx.fill();

        // occasional “pop” sparkle toward tip (tiny)
        if ((i % 7) === 0 && a > 0.3){
          ctx.beginPath();
          ctx.arc(x, y, s*1.2, 0, Math.PI*2);
          ctx.fillStyle = 'rgba(255,255,255,'+(0.7*a)+')';
          ctx.fill();
        }
        ctx.restore();
      }

      ctx.restore();
    }
  });
}


  function nearestTargetAhead(preferFlying = true){
    let best = null, bestScore = Infinity;
    const px = PLAYER.x + PLAYER.w;
    for (const o of obstacles){
      const dx = o.x - px;
      if (dx <= 0) continue;
      const priority = (preferFlying && o.type === 'squirrel') ? -60 : 0;
      const score = dx + priority;
      if (score < bestScore){ best = o; bestScore = score; }
    }
    return best;
  }

  function fireLightning(){
    if (!STATE.started || !POWER.have) return;
    const target = nearestTargetAhead();
    if (!target) return;
    POWER.have = false; boltIcon.style.display='none'; fireBtn.style.display = 'none';
    const start = { x: PLAYER.x + PLAYER.w/2 + 6, y: PLAYER.y + PLAYER.h*0.35 };
    projectiles.push({ x:start.x, y:start.y, target, speed:18, history:[] });
    explodeAt(start.x, start.y, 10, 160, true);
  }

  function obstacleCenter(o){
    const box = o.box();
    return { x: box.x + box.w/2, y: box.y + box.h/2 };
  }

  function explodeAt(x,y, count=24, spread=320, quiet=false){
    for (let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const m = (Math.random()*spread + 60) / 120;
      particles.push({
        x, y,
        vx: Math.cos(a)*m, vy: Math.sin(a)*m*0.8,
        life: 260 + Math.random()*300,
        color: i%2 ? 'rgba(190,230,255,0.95)' : 'rgba(130,210,255,0.9)'
      });
    }
    particles.push({ x, y, vx:0, vy:0, life:140, ring:true, color:'rgba(200,240,255,0.9)' });
    if (!quiet){
      for (let i=0;i<8;i++){
        const a = Math.random()*Math.PI*2, m = 2+Math.random()*3;
        particles.push({ x, y, vx:Math.cos(a)*m, vy:Math.sin(a)*m, life:200+Math.random()*200, color:'rgba(170,225,255,0.95)' });
      }
    }
  }

  // Render
  function draw(now){
    ctx.clearRect(0,0,W,H);
    BG.draw(ctx);
    drawGround();
    drawPlayer();

    // powerups
    for (const p of powerups) p.draw();

    // obstacles
    for (const o of obstacles) o.draw();

    // ——— PROJECTILES (lighter outline now; glow/core preserved) ———
    for (const b of projectiles){
      ctx.save();
      const trail = b.history;
      const pulse = 0.9 + Math.sin(now*0.02)*0.1;

      for (let t=trail.length-1;t>0;t--){
        const p1 = trail[t], p0 = trail[t-1];
        const age = Math.min(1, (now - p1.t)/150);

        // Subtle dark edge (reduced from the previous heavy outline)
        ctx.globalCompositeOperation = 'source-over';
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = 3 + (1-age)*2;
        ctx.strokeStyle = `rgba(0,0,0,${0.45*(1-age)})`;
        ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();

        // Blue glow
        ctx.globalCompositeOperation = 'lighter';
        ctx.lineWidth = 3 + (1-age)*3;
        ctx.strokeStyle = `rgba(143,211,255,${(0.8 - age*0.7)*pulse})`;
        ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();

        // White-hot core
        ctx.lineWidth = 1.2;
        ctx.strokeStyle = `rgba(255,255,255,${(0.9 - age*0.85)*pulse})`;
        ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
      }

      // head glow + slight dark dot
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.beginPath(); ctx.arc(b.x, b.y, 5.5, 0, Math.PI*2); ctx.fill();

      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(200,240,255,0.98)';
      ctx.beginPath(); ctx.arc(b.x, b.y, 3.8, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // particles
    for (const p of particles){
      if (p.ring){
        const k = 1 - (p.life/140);
        ctx.save();
        ctx.globalAlpha = 1 - k;
        ctx.strokeStyle = p.color; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(p.x, p.y, 12 + k*28, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
      } else {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 2, 2);
      }
    }
  }

  function drawGround(){
    ctx.fillStyle = '#3a3328'; ctx.fillRect(0,GROUND_Y,W,GROUND_H);
    ctx.fillStyle = '#4a4238';
    const seg=24, off=Math.floor((performance.now()/30)%seg);
    for(let x=-off;x<W;x+=seg){ ctx.fillRect(x,GROUND_Y+GROUND_H-6,12,3); }
  }

  function drawPlayer(){
    const img = (PLAYER.duck && STATE.started) ? IMG.beanDuck : IMG.beanRun;
    drawImage(img, PLAYER.x, PLAYER.y, PLAYER.w, PLAYER.h, 0);
  }

  // helpers
  function drawImage(img, x, y, w, h, rot){
    ctx.save(); ctx.imageSmoothingEnabled = false; ctx.translate(x + w/2, y + h/2);
    if (rot) ctx.rotate(rot);
    ctx.drawImage(img, 0, 0, img.width, img.height, -w/2, -h/2, w, h);
    ctx.restore();
  }
  function rand(min,max){ return Math.random()*(max-min)+min; }

  // Navbar inject
  fetch('navbar.html').then(r=>r.text()).then(html=>{ const nav=document.createElement('div'); nav.innerHTML=html; document.body.insertBefore(nav, document.body.firstChild); });
  </script>
</body>
</html>
