<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bean Run</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    /* Page‑scoped styles only */
    body.game-page { overflow: hidden; }
    .game-section { max-width: 980px; margin: 2rem auto 3rem; padding: 0 1rem; }
    .game-wrap { position: relative; width: 100%; max-width: 960px; aspect-ratio: 3 / 1; margin: 1rem auto; border-radius: 10px; overflow: hidden; box-shadow: 0 12px 28px rgba(0,0,0,.35); background:#111; }
    canvas { width: 100%; height: 100%; display: block; image-rendering: pixelated; image-rendering: crisp-edges; }
    .hud { position:absolute; inset:0; pointer-events:none; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#eee; }
    .hud .hi { position:absolute; top:8px; left:12px; opacity:.85; text-shadow:0 1px 0 #0008; }
    .hud .score { position:absolute; top:8px; right:12px; font-weight:700; text-shadow:0 1px 0 #0008; }
    .center { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; }
    .card { background:rgba(0,0,0,.6); color:#eee; border:1px solid #ffffff1a; border-radius:10px; padding:14px 18px; text-align:center; }
    .sub { font-size:.92rem; opacity:.9; }
  </style>
</head>
<body class="game-page">

  <main class="game-section content-box">
    <h1 class="section-title">BEAN RUN</h1>
    <p class="reverent-text">Help Bean sprint through the haunted forest — dodge the evil squirrels!</p>

    <div class="game-wrap">
      <canvas id="game" width="960" height="320" tabindex="0" aria-label="Bean Run"></canvas>
      <div class="hud">
        <div class="hi" id="hi">HI 00000</div>
        <div class="score" id="score">00000</div>
        <div class="center" id="center">
          <div class="card">
            <div style="font-weight:700">Press Space / Tap to begin</div>
            <div class="sub">Jump: Space / ▲ &nbsp;•&nbsp; Duck: ▼ &nbsp;•&nbsp; Pause: P</div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
  // ===== Bean Run — Forest Parallax Build =====
  // Bean:   img/bean_run.png (single frame) for run & jump
  // Duck:   img/bean_duck.png (single frame)
  // Enemy:  img/squirrel.png (flying, single frame) with vertical bob + slight tilt
  // Ground: img/swordsquirrel.png (ground obstacle, slides R→L)

  // Canvas
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // HUD
  const scoreEl = document.getElementById('score');
  const hiEl = document.getElementById('hi');
  const centerEl = document.getElementById('center');
  const fmt = n => n.toString().padStart(5,'0');

  // State
  const STATE = {
    started:false, running:false, paused:false, over:false,
    last:0, speed:6,
    score:0, hi: Number(sessionStorage.getItem('bean_hi') || 0),
    gravity: 1.05
  };

  // World
  const GROUND_Y = H - 48, GROUND_H = 20;
  const BEAN_FOOT_SINK = 4; // helps seat Bean a few px into the ground visually
  const groundTop = (h) => GROUND_Y - h + BEAN_FOOT_SINK;

  const PLAYER = { x:80, y:groundTop(40), w:44, h:40, vy:0, duck:false, onGround:true };
  const obstacles = [];
  let spawnCooldown = 900; // ms until next obstacle

  // ---------- Assets (single-frame sprites) ----------
  const IMG = {
    beanRun: new Image(),
    beanDuck: new Image(),
    squirrel: new Image(),      // flying enemy
    swordSquirrel: new Image(), // ground enemy
  };
  IMG.beanRun.src = 'img/bean_run.png';
  IMG.beanDuck.src = 'img/bean_duck.png';
  IMG.squirrel.src = 'img/squirrel.png';
  IMG.swordSquirrel.src = 'img/swordsquirrel.png';

  // ---------- Forest Parallax Background ----------
  const BG = makeForestBackground(W, H, GROUND_Y);

  function makeForestBackground(W, H, groundY){
    const layers = [
      makeLayer(W, H, groundY, {speedMul:0.25, hue:'#243147', trunk:'#1a2333', scale:0.75, jitterY:6}),
      makeLayer(W, H, groundY, {speedMul:0.45, hue:'#193a2f', trunk:'#11281f', scale:0.95, jitterY:8}),
      makeLayer(W, H, groundY, {speedMul:0.75, hue:'#0f3d24', trunk:'#0b2a19', scale:1.15, jitterY:10}),
    ];

    let skyGrad; // built on first draw to use real canvas size
    return {
      update(dts, worldSpeed){
        for(const L of layers){
          L.offset -= worldSpeed * L.speedMul * dts;
          if (L.offset <= -L.canvas.width) L.offset += L.canvas.width; // tile
        }
      },
      draw(ctx){
        // sky gradient
        if (!skyGrad){
          skyGrad = ctx.createLinearGradient(0,0,0,H);
          skyGrad.addColorStop(0.00, '#0a0f1c');
          skyGrad.addColorStop(0.45, '#13213a');
          skyGrad.addColorStop(0.85, '#0b1a22');
          skyGrad.addColorStop(1.00, '#0b1a22');
        }
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0,0,W,H);

        ctx.imageSmoothingEnabled = false;
        for(const L of layers){
          const x1 = Math.floor(L.offset);
          const x2 = x1 + L.canvas.width;
          ctx.drawImage(L.canvas, x1, 0);
          ctx.drawImage(L.canvas, x2, 0);
        }

        // forest floor to blend with ground strip
        ctx.fillStyle = '#0b1f13';
        ctx.fillRect(0, groundY, W, H - groundY);
      }
    };

    function makeLayer(W, H, groundY, opts){
      const c = document.createElement('canvas');
      const g = c.getContext('2d');
      c.width = Math.max(W, 512);
      c.height = H;

      g.clearRect(0,0,c.width,c.height);

      // repeating treeline clusters
      const base = groundY;
      const step = 26; // spacing between clusters
      for (let x = -20; x < c.width + 40; x += step){
        const s = opts.scale * (0.85 + Math.random()*0.3);
        const y = base + Math.floor((Math.random()*opts.jitterY) - opts.jitterY*0.5);
        const cluster = 2 + (Math.random() < 0.5 ? 1 : 0); // 2–3 trees per cluster
        for (let i=0;i<cluster;i++){
          drawPine(g,
            Math.floor(x + (i-0.5)*8),
            y,
            Math.floor(34*s*(1 + i*0.05)),
            opts.hue,
            opts.trunk
          );
        }
      }
      return {canvas:c, offset:0, speedMul:opts.speedMul};
    }

    function drawPine(g, x, baseY, h, leafColor, trunkColor){
      const w = Math.max(10, Math.floor(h*0.38));
      const trunkW = Math.max(3, Math.floor(w*0.18));
      const trunkH = Math.max(4, Math.floor(h*0.18));
      const topY = baseY - h;

      // canopy: stacked triangles
      g.fillStyle = leafColor;
      const tiers = 3;
      for (let t=0; t<tiers; t++){
        const ty = Math.floor(topY + (t/tiers)*h*0.75);
        const tw = Math.floor(w - t*(w*0.22));
        drawIsoTri(g, x, ty, tw, Math.floor(h*0.30));
      }

      // trunk
      g.fillStyle = trunkColor;
      g.fillRect(
        Math.floor(x - trunkW/2),
        Math.floor(baseY - trunkH),
        trunkW,
        trunkH
      );
    }

    function drawIsoTri(g, cx, topY, baseW, h){
      const half = Math.floor(baseW/2);
      g.beginPath();
      g.moveTo(Math.floor(cx), Math.floor(topY));
      g.lineTo(Math.floor(cx - half), Math.floor(topY + h));
      g.lineTo(Math.floor(cx + half), Math.floor(topY + h));
      g.closePath();
      g.fill();
    }
  }

  // ---------- Input ----------
  function startGame(){
    STATE.started = true; STATE.running = true; STATE.over = false; STATE.paused = false;
    STATE.score = 0; STATE.speed = 6; obstacles.length = 0; spawnCooldown = 900;
    Object.assign(PLAYER, { y: groundTop(40), w:44, h:40, vy:0, duck:false, onGround:true });
    centerEl.style.display = 'none';
    STATE.last = performance.now();
    requestAnimationFrame(loop);
  }
  const startIfReady = ()=>{ if (!STATE.started || STATE.over) startGame(); };
  function jump(){ if (!STATE.running || STATE.paused || STATE.over) return; if (PLAYER.onGround){ PLAYER.vy = -10.2; PLAYER.onGround = false; PLAYER.duck = false; } }
  function setDuck(d){ if (!STATE.running || STATE.paused || STATE.over) return; PLAYER.duck = !!d; }
  function togglePause(){ if (!STATE.started || STATE.over) return; STATE.paused = !STATE.paused; centerEl.style.display = STATE.paused ? 'flex' : 'none'; }

  window.addEventListener('keydown', (e)=>{
    if (e.code==='Space' || e.code==='ArrowUp'){ e.preventDefault(); if (!STATE.started || STATE.over) startGame(); else jump(); }
    if (e.code==='ArrowDown') setDuck(true);
    if (e.code==='KeyP' || e.code==='Escape') togglePause();
  });
  window.addEventListener('keyup', (e)=>{ if (e.code==='ArrowDown') setDuck(false); });
  canvas.addEventListener('click', (e)=>{ e.preventDefault(); startIfReady(); });
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); startIfReady(); }, {passive:false});
  document.addEventListener('DOMContentLoaded', ()=>{ try{ canvas.focus(); }catch{} });

  // ---------- Loop ----------
  function loop(now){
    if (!STATE.running) return;
    const dt = Math.min(32, now - STATE.last);
    const dts = dt / (1000/60);
    STATE.last = now;
    if (!STATE.paused){ update(dts, dt); draw(); }
    requestAnimationFrame(loop);
  }

  function update(dts, dt){
    // Speed ramp
    if (STATE.score < 300) STATE.speed += 0.0005 * dts;
    else if (STATE.score < 800) STATE.speed += 0.0008 * dts;
    else STATE.speed += 0.0011 * dts;

    // Background parallax
    BG.update(dts, STATE.speed);

    // Spawn progression
    spawnCooldown -= dt;
    if (spawnCooldown <= 0){
      spawnObstacle();
      spawnCooldown = rand(currentGapMin(), currentGapMax());
    }

    // Player physics
    if (!PLAYER.onGround){
      PLAYER.vy += STATE.gravity * dts * 0.5;
      PLAYER.y  += PLAYER.vy * dts;
      if (PLAYER.y >= groundTop(PLAYER.h)) {
        PLAYER.y = groundTop(PLAYER.h);
        PLAYER.vy = 0;
        PLAYER.onGround = true;
      }
    } else if (PLAYER.duck){
      PLAYER.h = 32;
      PLAYER.y = groundTop(PLAYER.h);
    } else {
      PLAYER.h = 40;
      PLAYER.y = groundTop(PLAYER.h);
    }

    // Obstacles
    for (let i = obstacles.length - 1; i >= 0; i--){
      const o = obstacles[i];
      o.x -= STATE.speed * dts;
      if (o.x + o.w < -10) { obstacles.splice(i,1); continue; }
      if (hit(playerBox(), o.box())) { return gameOver(); }
    }

    STATE.score += 0.35 * dts;
    scoreEl.textContent = fmt(Math.floor(STATE.score));
    hiEl.textContent = 'HI ' + fmt(STATE.hi);
  }

  function gameOver(){
    STATE.running = false; STATE.over = true;
    const s = Math.floor(STATE.score);
    if (s > STATE.hi){ STATE.hi = s; sessionStorage.setItem('bean_hi', String(s)); }
    scoreEl.textContent = fmt(s); hiEl.textContent = 'HI ' + fmt(STATE.hi);
    centerEl.style.display = 'flex';
    centerEl.querySelector('.card').innerHTML = `<div style="font-weight:700">Game Over</div><div>Score: ${fmt(s)}</div><div class="sub" style="margin-top:.25rem">Press Space / Tap to retry</div>`;
  }

  // ---------- Obstacles ----------
  function spawnObstacle(){
    let type = 0; // sword-squirrel (ground) by default
    if (STATE.score > 180){
      const flyerChance = STATE.score > 500 ? 0.45 : 0.25; // flying squirrels appear later
      type = Math.random() < flyerChance ? 1 : 0;
    }
    obstacles.push(type === 0 ? SwordSquirrel() : Squirrel());
  }
  function currentGapMin(){ return STATE.score < 150 ? 900 : STATE.score < 350 ? 750 : STATE.score < 700 ? 600 : 480; }
  function currentGapMax(){ return STATE.score < 150 ? 1500 : STATE.score < 350 ? 1300 : STATE.score < 700 ? 1100 : 950; }

  function SwordSquirrel(){
    // Render the 64x64 sprite at ~70% so it sits nicely on the ground line
    const SPRITE_W = 64, SPRITE_H = 64, SCALE = 0.70;
    const w = Math.round(SPRITE_W * SCALE);
    const h = Math.round(SPRITE_H * SCALE);
    const y = GROUND_Y - h + 6; // slight sink to feel grounded

    // Tight hitbox: trims sword glow/tail fluff so there’s no “air” collisions
    const inset = {
      left:  Math.round(w * 0.12),
      right: Math.round(w * 0.10),
      top:   Math.round(h * 0.14),
      bot:   Math.round(h * 0.08),
    };

    return {
      type: 'sword_squirrel',
      x: W + 10, y, w, h,
      box(){
        return {
          x: this.x + inset.left,
          y: this.y + inset.top,
          w: this.w - inset.left - inset.right,
          h: this.h - inset.top - inset.bot
        };
      },
      draw(){
        ctx.imageSmoothingEnabled = false;
        drawImage(IMG.swordSquirrel, this.x, this.y, this.w, this.h, 0);
        // // Debug hitbox
        // const b = this.box();
        // ctx.strokeStyle = 'rgba(255,0,0,.5)';
        // ctx.strokeRect(Math.round(b.x), Math.round(b.y), Math.round(b.w), Math.round(b.h));
      }
    };
  }

  function Squirrel(){
    // lower lanes so you must actually jump
    const lanes = [GROUND_Y - 80, GROUND_Y - 120];  // was -100, -140
    const baseY = lanes[Math.floor(Math.random()*lanes.length)];
    const amp = 8 + Math.random()*8;               // smaller bob so lows stay low
    const period = 1000 + Math.random()*500;
    const born = performance.now();

    // render size a touch larger for fair collision
    const w = 52, h = 40;                           // was 48,36
    return {
      type:'squirrel', x: W+10, y: baseY, w, h,
      box(){ const p = 2; return { x:this.x+p, y:this.y+p, w:this.w-2*p, h:this.h-2*p }; },
      draw(){
        const t = (performance.now() - born) / period;
        const bob = Math.sin(t * Math.PI * 2) * amp;
        const tilt = Math.sin(t * Math.PI * 2) * 0.12; // ~7º each way
        this.y = baseY + bob;
        if (IMG.squirrel.complete){
          drawImage(IMG.squirrel, this.x, this.y, this.w, this.h, tilt);
        } else {
          // fallback blob
          ctx.fillStyle = '#1b1b1b'; ctx.fillRect(this.x, this.y + this.h - 4, this.w, 4);
          ctx.fillStyle = '#111';     ctx.fillRect(this.x + 6, this.y + 8, this.w - 12, this.h - 12);
          ctx.fillStyle = '#700';     ctx.fillRect(this.x + 2, this.y + 6, 12, 6);
          ctx.fillStyle = '#700';     ctx.fillRect(this.x + this.w - 14, this.y + 6, 12, 6);
          ctx.fillStyle = '#111';     ctx.fillRect(this.x + this.w - 10, this.y + 8, 8, 6);
        }
      }
    };
  }

  // ---------- Collision ----------
  const playerBox = () => { const p=6; return {x:PLAYER.x+p, y:PLAYER.y+p, w:PLAYER.w-2*p, h:PLAYER.h-2*p}; };
  const hit = (a,b) => a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;

  // ---------- Render ----------
  function draw(){
    ctx.clearRect(0,0,W,H);
    BG.draw(ctx);     // forest parallax
    drawGround();     // foreground ground strip
    drawPlayer();
    for (const o of obstacles){ o.draw(); }
  }

  function drawGround(){
    // dirt path to match forest
    ctx.fillStyle = '#2a261f';
    ctx.fillRect(0,GROUND_Y,W,GROUND_H);
    ctx.fillStyle = '#3a3328';
    const seg=24, off=Math.floor((performance.now()/30)%seg);
    for(let x=-off;x<W;x+=seg){ ctx.fillRect(x,GROUND_Y+GROUND_H-6,12,3); }
  }

  function drawPlayer(){
    const img = (PLAYER.duck && PLAYER.onGround) ? IMG.beanDuck : IMG.beanRun;
    drawImage(img, PLAYER.x, PLAYER.y, PLAYER.w, PLAYER.h, 0);
  }

  // ---------- helpers ----------
  function drawImage(img, x, y, w, h, rot){
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.translate(x + w/2, y + h/2);
    if (rot) ctx.rotate(rot);
    ctx.drawImage(img, 0, 0, img.width, img.height, -w/2, -h/2, w, h);
    ctx.restore();
  }
  const rand = (min,max)=> Math.random()*(max-min)+min;

  // Navbar inject (simple)
  fetch('navbar.html').then(r=>r.text()).then(html=>{ const nav=document.createElement('div'); nav.innerHTML=html; document.body.insertBefore(nav, document.body.firstChild); });
  </script>
</body>
</html>
