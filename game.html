<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bean Run — Lightning</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    body.game-page { overflow: hidden; }
    .game-section { max-width: 980px; margin: 2rem auto 3rem; padding: 0 1rem; }
    .game-wrap { position: relative; width: 100%; max-width: 960px; aspect-ratio: 3 / 1; margin: 1rem auto; border-radius: 10px; overflow: hidden; box-shadow: 0 12px 28px rgba(0,0,0,.35); background:#111; }
    canvas { width: 100%; height: 100%; display: block; image-rendering: pixelated; image-rendering: crisp-edges; }
    .hud { position:absolute; inset:0; pointer-events:none; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#eee; }
    .hud .hi { position:absolute; top:8px; left:12px; opacity:.85; text-shadow:0 1px 0 #0008; }
    .hud .score { position:absolute; top:8px; right:12px; font-weight:700; text-shadow:0 1px 0 #0008; }
    .center { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; }
    .card { background:rgba(0,0,0,.35); backdrop-filter: blur(2px); color:#eee; border:1px solid #ffffff1a; border-radius:10px; padding:14px 18px; text-align:center; }
    .card h2{ margin:.2rem 0 .25rem; letter-spacing:.02em; }
    .sub { font-size:.92rem; opacity:.9; }
    .blink { animation: blink 1.6s infinite; }
    @keyframes blink { 0%,100%{opacity:.35} 50%{opacity:.95} }
    /* Floating fire button */
    #lightningBtn{
      position:fixed; right:14px; bottom:14px; width:64px; height:64px; border-radius:12px;
      font-size:28px; z-index:9999; display:none; border:none; cursor:pointer; pointer-events:auto;
      background:linear-gradient(#ffd54a,#ffb300); box-shadow:0 6px 18px rgba(0,0,0,0.4);
    }
  </style>
</head>
<body class="game-page">

  <main class="game-section content-box">
    <h1 class="section-title">BEAN RUN</h1>
    <p class="reverent-text">Grab ⚡ power and smite the evil squirrels!</p>

    <div class="game-wrap">
      <canvas id="game" width="960" height="320" tabindex="0" aria-label="Bean Run"></canvas>
      <div class="hud">
        <div class="hi" id="hi">HI 00000</div>
        <div class="score" id="score">00000</div>
        <div class="center" id="center">
          <div class="card start">
            <h2>Bean Run</h2>
            <p class="sub" style="margin:.1rem 0 .5rem">Jump / duck to survive. Collect ⚡ then press it (or Z) to blast a squirrel ahead.</p>
            <div class="sub blink">Click / Tap / Space to Start</div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <button id="lightningBtn" aria-label="Fire Lightning">⚡</button>

  <script>
  // ===== Bean Run — Forest Parallax + Lightning Power =====

  // Canvas
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const FRAME_MS = 1000/60;

  // HUD
  const scoreEl = document.getElementById('score');
  const hiEl = document.getElementById('hi');
  const centerEl = document.getElementById('center');
  const fireBtn = document.getElementById('lightningBtn');
  const fmt = n => n.toString().padStart(5,'0');

  // State
  const STATE = {
    started:false, paused:false, over:false,
    last:0, speed:6,
    score:0, hi: Number(sessionStorage.getItem('bean_hi') || 0),
    gravity: 1.05
  };

  // World
  const GROUND_Y = H - 48, GROUND_H = 20;
  const BEAN_FOOT_SINK = 4;
  const groundTop = (h) => GROUND_Y - h + BEAN_FOOT_SINK;

  const PLAYER = { x:80, y:groundTop(40), w:44, h:40, vy:0, duck:false, onGround:true };

  const obstacles = [];
  let spawnCooldown = 900;

  // Attract/demo settings
  const DEMO = { speedTarget: 2.8, maxObstacles: 2, minGapPx: 260, spawnMin: 1200, spawnMax: 1700, jumpCooldownMs: 650, horizonFrames: 180, jumpVy: -9.6 };
  let demoCooldown = rand(DEMO.spawnMin, DEMO.spawnMax);
  let lastJumpAt = 0;

  // Power-ups / projectiles / particles
  const powerups = [];
  const projectiles = [];
  const particles = [];

  const POWER = {
    have:false,           // collected and ready to fire
    spawnEveryScore: 120, // minimum score delta between spawns
    lastSpawnScore: -999,
    spawnChance: 0.55,    // try fairly often (still bounded by score gap)
    scoreBonus: 18
  };

  // Assets
  const IMG = {
    beanRun: new Image(),
    beanDuck: new Image(),
    squirrel: new Image(),
    swordSquirrel: new Image(),
  };
  IMG.beanRun.src = 'img/bean_run.png';
  IMG.beanDuck.src = 'img/bean_duck.png';
  IMG.squirrel.src = 'img/squirrel.png';
  IMG.swordSquirrel.src = 'img/swordsquirrel.png';

  // Background
  const BG = makeForestBackground(W, H, GROUND_Y);

  function makeForestBackground(W, H, groundY){
    const layers = [
      makeLayer(W, H, groundY, {speedMul:0.26, hue:'#50915a', trunk:'#37623c', baseH:44, scale:0.95, jitterY:6,  step:26}),
      makeLayer(W, H, groundY, {speedMul:0.48, hue:'#3e864f', trunk:'#2f613b', baseH:56, scale:1.18, jitterY:8,  step:24}),
      makeLayer(W, H, groundY, {speedMul:0.80, hue:'#2f7a45', trunk:'#255d36', baseH:66, scale:1.38, jitterY:10, step:22}),
    ];
    let skyGrad;
    return {
      update(dts, worldSpeed){
        for(const L of layers){
          L.offset -= worldSpeed * L.speedMul * dts;
          if (L.offset <= -L.canvas.width) L.offset += L.canvas.width;
        }
      },
      draw(ctx){
        if (!skyGrad){
          skyGrad = ctx.createLinearGradient(0,0,0,H);
          skyGrad.addColorStop(0.00, '#cfe8ff');
          skyGrad.addColorStop(0.55, '#b8dcff');
          skyGrad.addColorStop(1.00, '#a2d0ff');
        }
        ctx.fillStyle = skyGrad; ctx.fillRect(0,0,W,H);
        ctx.imageSmoothingEnabled = false;
        for(const L of layers){
          const x1 = Math.floor(L.offset);
          const x2 = x1 + L.canvas.width;
          ctx.drawImage(L.canvas, x1, 0);
          ctx.drawImage(L.canvas, x2, 0);
        }
        ctx.fillStyle = '#20331f'; ctx.fillRect(0, groundY, W, H - groundY);
      }
    };
    function makeLayer(W, H, groundY, opts){
      const c = document.createElement('canvas');
      const g = c.getContext('2d');
      c.width = Math.max(W, 640); c.height = H;
      const base = groundY, step = opts.step || 24;
      for (let x = -20; x < c.width + 40; x += step){
        const s = opts.scale * (0.9 + Math.random()*0.35);
        const y = base + Math.floor((Math.random()*opts.jitterY) - opts.jitterY*0.5);
        const cluster = 2 + (Math.random() < 0.6 ? 1 : 0);
        for (let i=0;i<cluster;i++){
          drawPine(g, Math.floor(x + (i-0.5)*10), y, Math.floor((opts.baseH||48)*s*(1 + i*0.05)), opts.hue, opts.trunk);
        }
      }
      return {canvas:c, offset:0, speedMul:opts.speedMul};
    }
    function drawPine(g, x, baseY, h, leafColor, trunkColor){
      const w = Math.max(12, Math.floor(h*0.42));
      const trunkW = Math.max(3, Math.floor(w*0.18));
      const trunkH = Math.max(5, Math.floor(h*0.22));
      const topY = baseY - h;
      g.fillStyle = leafColor;
      const tiers = 3;
      for (let t=0; t<tiers; t++){
        const ty = Math.floor(topY + (t/tiers)*h*0.78);
        const tw = Math.floor(w - t*(w*0.22));
        drawIsoTri(g, x, ty, tw, Math.floor(h*0.34));
      }
      g.fillStyle = trunkColor;
      g.fillRect(Math.floor(x - trunkW/2), Math.floor(baseY - trunkH), trunkW, trunkH);
    }
    function drawIsoTri(g, cx, topY, baseW, h){
      const half = Math.floor(baseW/2);
      g.beginPath();
      g.moveTo(Math.floor(cx), Math.floor(topY));
      g.lineTo(Math.floor(cx - half), Math.floor(topY + h));
      g.lineTo(Math.floor(cx + half), Math.floor(topY + h));
      g.closePath(); g.fill();
    }
  }

  // Input
  function startGame(){
    STATE.started = true; STATE.over = false; STATE.paused = false;
    STATE.score = 0; STATE.speed = 6; obstacles.length = 0; spawnCooldown = 900; lastJumpAt = 0;
    powerups.length = 0; projectiles.length = 0; particles.length = 0; POWER.have = false; fireBtn.style.display = 'none';
    Object.assign(PLAYER, { y: groundTop(40), w:44, h:40, vy:0, duck:false, onGround:true });
    centerEl.style.display = 'none';
  }
  const startIfReady = ()=>{ if (!STATE.started || STATE.over) startGame(); };
  function jump(){ if (!STATE.started || STATE.paused || STATE.over) return; if (PLAYER.onGround){ PLAYER.vy = -10.2; PLAYER.onGround = false; PLAYER.duck = false; } }
  function setDuck(d){ if (!STATE.started || STATE.paused || STATE.over) return; PLAYER.duck = !!d; }
  function togglePause(){ if (!STATE.started || STATE.over) return; STATE.paused = !STATE.paused; centerEl.style.display = STATE.paused ? 'flex' : 'none'; }

  window.addEventListener('keydown', (e)=>{
    if (e.code==='Space' || e.code==='ArrowUp'){ e.preventDefault(); if (!STATE.started || STATE.over) startGame(); else jump(); }
    if (e.code==='ArrowDown') setDuck(true);
    if (e.code==='KeyZ') fireLightning();
    if (e.code==='KeyP' || e.code==='Escape') togglePause();
  });
  window.addEventListener('keyup', (e)=>{ if (e.code==='ArrowDown') setDuck(false); });
  canvas.addEventListener('click', (e)=>{ e.preventDefault(); startIfReady(); });
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); startIfReady(); }, {passive:false});
  fireBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); fireLightning(); });

  document.addEventListener('DOMContentLoaded', ()=>{ try{ canvas.focus(); }catch{} });

  // Loop
  requestAnimationFrame(loop);
  function loop(now){
    const dt = Math.min(32, now - STATE.last);
    const dts = dt / (1000/60);
    STATE.last = now;

    if (!STATE.paused){
      if (STATE.started) updatePlay(dts, dt, now); else updateAttract(dts, dt, now);
      draw(now);
    }
    requestAnimationFrame(loop);
  }

  // Update: Play
  function updatePlay(dts, dt, now){
    // speed ramp
    if (STATE.score < 300) STATE.speed += 0.0005 * dts;
    else if (STATE.score < 800) STATE.speed += 0.0008 * dts;
    else STATE.speed += 0.0011 * dts;

    BG.update(dts, STATE.speed);

    // spawn progression
    spawnCooldown -= dt;
    if (spawnCooldown <= 0){
      // maybe power-up instead of obstacle
      if (!POWER.have && canSpawnPower() && Math.random() < POWER.spawnChance){
        spawnPowerup();
      } else {
        spawnObstacle();
      }
      spawnCooldown = rand(currentGapMin(), currentGapMax());
    }

    // player physics
    if (!PLAYER.onGround){
      PLAYER.vy += STATE.gravity * dts * 0.5;
      PLAYER.y  += PLAYER.vy * dts;
      if (PLAYER.y >= groundTop(PLAYER.h)) { PLAYER.y = groundTop(PLAYER.h); PLAYER.vy = 0; PLAYER.onGround = true; }
    } else if (PLAYER.duck){
      PLAYER.h = 32; PLAYER.y = groundTop(PLAYER.h);
    } else { PLAYER.h = 40; PLAYER.y = groundTop(PLAYER.h); }

    // move powerups & collect
    for (let i=powerups.length-1;i>=0;i--){
      const p = powerups[i];
      p.x -= STATE.speed * dts;
      if (p.x + p.w < -10) { powerups.splice(i,1); continue; }
      if (hit(playerBox(), p.box())){ powerups.splice(i,1); POWER.have = true; fireBtn.style.display = 'block'; }
    }

    // obstacles & collisions
    for (let i = obstacles.length - 1; i >= 0; i--){
      const o = obstacles[i];
      o.x -= STATE.speed * dts;
      if (o.x + o.w < -10) { obstacles.splice(i,1); continue; }
      if (hit(playerBox(), o.box())) { return gameOver(); }
    }

    // projectiles (homing)
    for (let i=projectiles.length-1;i>=0;i--){
      const bolt = projectiles[i];
      // re-acquire target center if still alive
      if (!bolt.target || !obstacles.includes(bolt.target) || bolt.target.type !== 'squirrel'){
        // try to find another squirrel ahead
        bolt.target = nearestSquirrelAhead();
        if (!bolt.target){ projectiles.splice(i,1); continue; }
      }
      const tc = obstacleCenter(bolt.target);
      const dx = tc.x - bolt.x, dy = tc.y - bolt.y;
      const dist = Math.hypot(dx,dy) || 1;
      const step = Math.min(bolt.speed * dts, dist);
      bolt.x += (dx / dist) * step;
      bolt.y += (dy / dist) * step;
      bolt.history.push({x:bolt.x, y:bolt.y, t:now});
      if (bolt.history.length > 12) bolt.history.shift();

      // impact?
      const b = {x: bolt.x-2, y: bolt.y-2, w:4, h:4};
      if (hit(b, bolt.target.box())){
        // blow up target
        explodeAt(tc.x, tc.y);
        // remove target
        const idx = obstacles.indexOf(bolt.target);
        if (idx >= 0) obstacles.splice(idx,1);
        // bonus
        STATE.score += POWER.scoreBonus;
        // consume projectile
        projectiles.splice(i,1);
        // if no more power, hide button
        if (!POWER.have) fireBtn.style.display = 'none';
      }
    }

    // particles
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.vx *= 0.98; p.vy += 0.22; // a bit of gravity
      p.x += p.vx * dts; p.y += p.vy * dts;
      p.life -= dt;
      if (p.life <= 0) particles.splice(i,1);
    }

    STATE.score += 0.35 * dts;
    scoreEl.textContent = fmt(Math.floor(STATE.score));
    hiEl.textContent = 'HI ' + fmt(STATE.hi);
  }

  // Update: Attract (unchanged except no power usage)
  function updateAttract(dts, dt, now){
    STATE.speed += (DEMO.speedTarget - STATE.speed) * 0.08 * dts;
    BG.update(dts, STATE.speed);

    demoCooldown -= dt;
    if (demoCooldown <= 0){
      if (obstacles.length < DEMO.maxObstacles && farEnoughFromLast(DEMO.minGapPx)){
        spawnObstacleDemo();
      }
      demoCooldown = rand(DEMO.spawnMin, DEMO.spawnMax);
    }

    const nowMs = performance.now();
    if (!PLAYER.onGround){
      PLAYER.vy += STATE.gravity * dts * 0.5;
      PLAYER.y  += PLAYER.vy * dts;
      if (PLAYER.y >= groundTop(PLAYER.h)) { PLAYER.y = groundTop(PLAYER.h); PLAYER.vy = 0; PLAYER.onGround = true; }
    } else {
      PLAYER.h = 40; PLAYER.y = groundTop(PLAYER.h);
      const o = nextObstacleAhead();
      if (o){
        const willHitIfNoJump = predictCollisionForObstacle(o, false);
        const willHitIfJump   = predictCollisionForObstacle(o, true);
        if (willHitIfNoJump && !willHitIfJump && (nowMs - lastJumpAt) > DEMO.jumpCooldownMs){
          PLAYER.vy = DEMO.jumpVy; PLAYER.onGround = false; lastJumpAt = nowMs;
